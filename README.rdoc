= KO!

This is KDD --Kickass Driven Development!

Knockout is a Ruby test framework that reads like a developer thinks.
More specifically, KO! is a behavior-driven design system created to 
breakdown the systems analysis proccess into clear and obvious divisions.
KO "tests" are divided-up into *contexts*, *features*, *scenarios*,  and
*assertions*.

* *Contexts* are used to setup and teardown test fixtures.

* *Features* delineate the overall requirement that a set of scenarios are designed to demonstrate.

* *Scenarios* compose the descriptive "proof" of a feature, via assertions.

* *Assertions* are the final validators, handled by simple conditional procedures.

KO! was inspired in part by the void left behind by the discontinuation of
Shoulda as a test framework. It seemed like an opportune time to give Ruby an
elegant, modern and light-weight BDD framework to serve as an alternative to
the monolithic RSpec.


== SYNOPSIS

=== Writing Kick-Ass Specs

KO! specifications... well here's an fracking example.

  feature "String Indexing" do

    string = "Hello World"

    scenario "index by substring" do
      to do |substring|
        string.index(substring)
      end

      ok 'H'  => 0
      ok 'l'  => 2
      ok 'ld' => 9
    end

    scenario "index by regular expression" do
      to do |regular_expression|
        @string.index(regular_expression)
      end

      ok /H/   => 0
      ok /l/   => 2
      ok /o\ / => 4
    end
  end

It should be pretty clear how this plays out just by looking at it. When KO
tests a feature it run each scenario, which consists of trying each +ok+
assertion. There are run thru the "to do" procedure, the result of which is
compared to the ok expectation given after the `=>`.

=== Alternate Assertions

KO! handles assertions in a rather unique way. By default only one type of
assertion is available, equality (==). This is by far the most common means
of test validation, but obviously it is not alwasy the validation required.
In these cases an alternate validation procedure can be defined.

  feature "Calculator Addition" do

    require 'calculator'

    calculator = Calculater.new

    scenario "a Calculator can add two numbers"
      to do |input1, input2|
        calculator.push input1
        calculator.push input2
        calculator.add
      end

      valid do |result, todo|
        calculator.output == result
      end

      ok [2, 2] => 4
      ok [2, 1] => 3
      ok [2, 0] => 2
    end

  end

A scenario can only ever have one +todo+ procedure and one +validation+ procedure.
This might seem somewhat limiting, but it helps keep a clean separation of concern
between scenarios.

=== Reusable Contexts

KO has a nice feature for creating reusable contexts. They can be defined 
outside of any featurem and then called upon by their description for use
in any feature.

  context "String Instance" do
    before :all do
      @string = "Hello World"
    end
  end

  feature "String Indexing" do

    use "String Instance"

    scenario "index by substring" do
      to do |substring|
        @string.index(substring)
      end

      ...

Get it? You create a reusable contexts --they can load libraries, build out mocks,
setup fixtures, etc. Then use +use+ to use them in your feature scenarios.

Of course, generally you won't define the contexts in the same file
with the features. You will put those in separate files in the context
drectory where it will be loaded up automatically ready for, yep, use.

Oh, if you are a Cuke, you can use captialized method names instead.

=== Running Those Suckers

Running KO! scripts is like this.

  $ ko -Ilib path/to/requirements/*.rb


== STATUS

KO! is pretty new, but it's also pretty straight-forward. It still needs
some work, for instance, on they way in which context are injected into 
features and/or sceanrios, but it works well enough as it is for general
wide-spread use.


== LEGAL

Copyright (c) 2010 Thomas Sawyer, Apache License 2.0


